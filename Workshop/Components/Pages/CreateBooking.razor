@rendermode InteractiveServer
@page "/create-booking"
@using Workshop.Models
@using Workshop.Services
@using Syncfusion.Blazor.Calendars
@inject WorkshopData Data
@inject JobCatalogService Catalog
@inject SchedulingService Scheduler
@inject NavigationManager Nav

<style>
    /* Fully booked days - red */
    .day-unavailable .e-day {
        background: #fee !important;
        color: #900 !important;
        border-radius: 6px;
        font-weight: 600;
    }

    .e-disabled.day-unavailable .e-day {
        opacity: 1 !important;
        cursor: not-allowed !important;
    }

    /* Closed days - grey */
    .day-closed .e-day {
        background: #f5f5f5 !important;
        color: #999 !important;
        border-radius: 6px;
        text-decoration: line-through;
    }

    .e-disabled.day-closed .e-day {
        opacity: 1 !important;
        cursor: not-allowed !important;
    }
</style>

<h3>Create booking</h3>

<div style="display:grid; gap:12px; max-width:720px;">
    <div>
        <label>Store</label><br />
        <select @bind="SelectedStoreId">
            @foreach (var s in Data.Stores)
            {
                <option value="@s.Id">@s.Name</option>
            }
        </select>
    </div>

    <div>
        <label>Mechanic</label><br />
        <select @bind="SelectedMechanicId">
            <option value="0">All</option>
            @foreach (var m in MechanicsForSelectedStore)
            {
                <option value="@m.Id">@m.Name</option>
            }
        </select>
    </div>

    <div>
        <label>Job</label><br />
        <select @bind="SelectedJobId">
            @foreach (var j in Catalog.Jobs)
            {
                <option value="@j.Id">@j.Name (@j.DefaultMinutes mins, £@j.BasePriceIncVat)</option>
            }
        </select>
    </div>

    <div>
        <label>Add ons</label><br />
        @foreach (var a in Catalog.AddOns)
        {
            <div>
                <input type="checkbox"
                       checked="@SelectedAddOns.Contains(a.Id)"
                       @onchange="e => ToggleAddOn(a.Id, e)" />
                <span>@a.Name</span>
            </div>
        }
    </div>

    <div>
        <label>Earliest day</label><br />

        <SfDatePicker TValue="DateTime?"
                      Value="EarliestDay"
                      Format="dd/MM/yyyy"
                      StrictMode="true"
                      AllowEdit="false"
                      Placeholder="Select a day">
            <DatePickerEvents TValue="DateTime?"
                              ValueChange="@OnEarliestDayChanged"
                              OnRenderDayCell="@OnCalendarRenderDayCell">
            </DatePickerEvents>
        </SfDatePicker>

        <div style="font-size:12px; color:#666; margin-top:6px;">
            We'll always schedule the earliest available slot on the selected day.
        </div>
    </div>

    <div style="padding:10px; border:1px solid #ddd;">
        <div><b>Calculated</b></div>
        <div>Minutes: @CalculatedMinutes</div>
        <div>Price inc VAT: £@CalculatedPrice.ToString("0.00")</div>
    </div>

    <div>
        <button @onclick="Create">Auto schedule</button>
    </div>

    @if (!string.IsNullOrWhiteSpace(Message))
    {
        <div style="padding:10px; border:1px solid #ddd;">
            @Message
        </div>
    }
</div>

@code {
    private int _selectedStoreId;
    private string _selectedJobId = "SVC_BRONZE";
    private int _selectedMechanicId = 0; // 0 = All

    private readonly HashSet<string> SelectedAddOns = new(StringComparer.OrdinalIgnoreCase);

    private DateTime? EarliestDay;
    private string Message = "";

    private int CalculatedMinutes;
    private decimal CalculatedPrice;

    // Days that cannot fit the selected job duration (for the month currently being rendered)
    private readonly HashSet<DateTime> UnavailableDays = new();
    
    // Days when the store is closed (for the month currently being rendered)
    private readonly HashSet<DateTime> ClosedDays = new();

    private int SelectedStoreId
    {
        get => _selectedStoreId;
        set
        {
            if (_selectedStoreId == value) return;
            _selectedStoreId = value;

            // If selected mechanic isn't in this store, reset to All
            var mechIds = MechanicsForSelectedStore.Select(m => m.Id).ToHashSet();
            if (_selectedMechanicId != 0 && !mechIds.Contains(_selectedMechanicId))
                _selectedMechanicId = 0;

            Recalc();
            SetDefaultDayIfNeeded();
            RefreshMonthAvailability();
            EnsureEarliestDayIsValid();
        }
    }

    private int SelectedMechanicId
    {
        get => _selectedMechanicId;
        set
        {
            if (_selectedMechanicId == value) return;
            _selectedMechanicId = value;

            RefreshMonthAvailability();
            EnsureEarliestDayIsValid();
        }
    }

    private string SelectedJobId
    {
        get => _selectedJobId;
        set
        {
            if (_selectedJobId == value) return;
            _selectedJobId = value;

            Recalc();
            RefreshMonthAvailability();
            EnsureEarliestDayIsValid();
        }
    }

    private IEnumerable<Mechanic> MechanicsForSelectedStore =>
        Data.Mechanics.Where(m => m.StoreId == SelectedStoreId);

    protected override void OnInitialized()
    {
        SelectedStoreId = Data.Stores.First().Id;

        Recalc();
        SetDefaultDayIfNeeded();
        RefreshMonthAvailability();
        EnsureEarliestDayIsValid();
    }

    private void SetDefaultDayIfNeeded()
    {
        if (EarliestDay.HasValue) return;

        var store = Data.Stores.First(s => s.Id == SelectedStoreId);
        var now = DateTime.Now;

        // Find the next open day
        var candidateDay = now.Date;
        
        // If we're past closing time today, start from tomorrow
        var todayClose = now.Date.Add(store.OpenTo);
        if (now > todayClose)
            candidateDay = candidateDay.AddDays(1);

        // Find next day the store is actually open
        for (int i = 0; i < 14; i++) // Check up to 2 weeks ahead
        {
            if (store.IsOpenOnDay(candidateDay))
            {
                EarliestDay = candidateDay;
                return;
            }
            candidateDay = candidateDay.AddDays(1);
        }

        // Fallback (shouldn't happen unless store never opens)
        EarliestDay = now.Date;
    }

    private void ToggleAddOn(string id, ChangeEventArgs e)
    {
        var isChecked = e?.Value is bool b && b;

        if (isChecked) SelectedAddOns.Add(id);
        else SelectedAddOns.Remove(id);

        Recalc();
        RefreshMonthAvailability();
        EnsureEarliestDayIsValid();
    }

    private void Recalc()
    {
        var (mins, price, _) = Catalog.PriceAndTime(SelectedJobId, SelectedAddOns.ToList());
        CalculatedMinutes = mins;
        CalculatedPrice = price;
    }

    private void RefreshMonthAvailability()
    {
        UnavailableDays.Clear();
        ClosedDays.Clear();

        if (CalculatedMinutes <= 0) return;

        var baseDay = (EarliestDay ?? DateTime.Today).Date;
        var store = Data.Stores.First(s => s.Id == SelectedStoreId);

        var monthStart = new DateTime(baseDay.Year, baseDay.Month, 1);
        var monthEnd = monthStart.AddMonths(1);

        int? mechanicFilter = _selectedMechanicId == 0 ? null : _selectedMechanicId;

        for (var d = monthStart; d < monthEnd; d = d.AddDays(1))
        {
            // Check if store is closed on this day
            if (!store.IsOpenOnDay(d))
            {
                ClosedDays.Add(d.Date);
                continue;
            }

            // Check if we can fit the job on this day
            var canFit = Scheduler.CanFitOnDay(SelectedStoreId, CalculatedMinutes, d, mechanicFilter);
            if (!canFit)
                UnavailableDays.Add(d.Date);
        }
    }

    private void EnsureEarliestDayIsValid()
    {
        if (!EarliestDay.HasValue)
            return;

        var day = EarliestDay.Value.Date;
        var store = Data.Stores.First(s => s.Id == SelectedStoreId);

        // Check if the selected day is a closed day
        if (ClosedDays.Contains(day))
        {
            var next = FindNextOpenDay(day);
            if (next.HasValue)
            {
                EarliestDay = next.Value;
                Message = "";
                RefreshMonthAvailability();
                return;
            }
            else
            {
                Message = "Store is closed on this day. Please select another day.";
                return;
            }
        }

        // First, try to move backward to find an earlier available day
        var earlierDay = FindEarlierAvailableDay(day);
        if (earlierDay.HasValue)
        {
            EarliestDay = earlierDay.Value;
            Message = "";
            RefreshMonthAvailability();
            return;
        }

        // If current day is unavailable, move forward to next available day
        if (UnavailableDays.Contains(day))
        {
            var next = FindNextAvailableDay(day);
            if (next.HasValue)
            {
                EarliestDay = next.Value;
                Message = "";
                RefreshMonthAvailability();
            }
            else
            {
                Message = "No availability found in the current range. Try a different job, store, or mechanic.";
            }
        }
    }

    private DateTime? FindNextOpenDay(DateTime fromDay)
    {
        var store = Data.Stores.First(s => s.Id == SelectedStoreId);
        var start = fromDay.Date.AddDays(1);
        var end = start.AddDays(14); // Check 2 weeks ahead

        for (var d = start; d <= end; d = d.AddDays(1))
        {
            if (store.IsOpenOnDay(d))
                return d.Date;
        }

        return null;
    }

    private DateTime? FindEarlierAvailableDay(DateTime fromDay)
    {
        var today = DateTime.Today;
        var start = fromDay.Date.AddDays(-1); // Start checking one day before current
        var store = Data.Stores.First(s => s.Id == SelectedStoreId);

        // Don't go earlier than today
        if (start < today) return null;

        int? mechanicFilter = _selectedMechanicId == 0 ? null : _selectedMechanicId;

        // Search backward from current day to today
        for (var d = start; d >= today; d = d.AddDays(-1))
        {
            // Skip closed days
            if (!store.IsOpenOnDay(d))
                continue;

            if (Scheduler.CanFitOnDay(SelectedStoreId, CalculatedMinutes, d, mechanicFilter))
                return d.Date;
        }

        return null;
    }

    private DateTime? FindNextAvailableDay(DateTime fromDay)
    {
        // Search up to 90 days ahead to keep it simple for now
        var start = fromDay.Date;
        var end = start.AddDays(90);
        var store = Data.Stores.First(s => s.Id == SelectedStoreId);

        int? mechanicFilter = _selectedMechanicId == 0 ? null : _selectedMechanicId;

        for (var d = start; d <= end; d = d.AddDays(1))
        {
            // Skip closed days
            if (!store.IsOpenOnDay(d))
                continue;

            // Make sure month cache is valid for the day we are checking
            // If we cross into a new month, rebuild UnavailableDays based on that month
            var currentBase = (EarliestDay ?? DateTime.Today).Date;
            if (d.Month != currentBase.Month || d.Year != currentBase.Year)
            {
                EarliestDay = d.Date;
                RefreshMonthAvailability();
            }

            if (Scheduler.CanFitOnDay(SelectedStoreId, CalculatedMinutes, d, mechanicFilter))
                return d.Date;
        }

        return null;
    }

    private void OnCalendarRenderDayCell(RenderDayCellEventArgs args)
    {
        var day = args.Date.Date;

        // Check if it's a closed day first (takes priority)
        if (ClosedDays.Contains(day))
        {
            args.IsDisabled = true;
            args.CellData.ClassList = (args.CellData.ClassList ?? "") + " day-closed";
        }
        // Then check if it's unavailable due to booking capacity
        else if (UnavailableDays.Contains(day))
        {
            args.IsDisabled = true;
            args.CellData.ClassList = (args.CellData.ClassList ?? "") + " day-unavailable";
        }
    }

    private void OnEarliestDayChanged(ChangedEventArgs<DateTime?> args)
    {
        var value = args.Value;

        if (!value.HasValue)
        {
            EarliestDay = null;
            return;
        }

        var picked = value.Value.Date;

        // Check if the picked day is closed
        if (ClosedDays.Contains(picked))
        {
            Message = "Store is closed on that day. Please select another day.";
            return;
        }

        // Check if the picked day is unavailable due to capacity
        if (UnavailableDays.Contains(picked))
        {
            Message = "No availability on that day for the selected job duration. Pick another day.";
            return;
        }

        Message = "";
        EarliestDay = picked;

        RefreshMonthAvailability();
    }

    private void Create()
    {
        Message = "";

        if (!EarliestDay.HasValue)
        {
            Message = "Pick an earliest day first.";
            return;
        }

        var store = Data.Stores.First(s => s.Id == SelectedStoreId);

        // Verify the selected day is not a closed day
        if (!store.IsOpenOnDay(EarliestDay.Value))
        {
            Message = "Store is closed on that day. Please select another day.";
            return;
        }

        var (mins, price, title) = Catalog.PriceAndTime(SelectedJobId, SelectedAddOns.ToList());

        int? mechanicFilter = _selectedMechanicId == 0 ? null : _selectedMechanicId;

        // earliest time is store opening time on selected day
        var dayStart = EarliestDay.Value.Date.Add(store.OpenFrom);
        var dayEnd = EarliestDay.Value.Date.Add(store.OpenTo);

        var slot = Scheduler.FindFirstSlot(SelectedStoreId, mins, dayStart, mechanicFilter);

        if (!slot.Found || slot.Start.Date != dayStart.Date || slot.End > dayEnd)
        {
            Message = "No availability on that day for the selected job duration.";
            return;
        }

        var id = Data.NextBookingId();

        Data.Bookings.Add(new Booking
        {
            Id = id,
            StoreId = SelectedStoreId,
            MechanicId = slot.MechanicId,
            Title = title,
            Start = slot.Start,
            End = slot.End,
            JobId = SelectedJobId,
            AddOnIds = SelectedAddOns.ToArray(),
            TotalMinutes = mins,
            TotalPriceIncVat = price
        });

        Nav.NavigateTo($"/store/{SelectedStoreId}");
    }
}
